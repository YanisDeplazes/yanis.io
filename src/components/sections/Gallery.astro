---
import Wrapper from '../../layouts/Wrapper.astro';
import ImageWrapper from '../wrappers/ImageWrapper.astro';
import VideoWrapper from '../wrappers/VideoWrapper.astro';

const { galleryData } = Astro.props;

// Dynamic imports
const images = import.meta.glob<{ default: ImageMetadata }>(
  '/src/assets/images/galleries/**/*.{jpg,jpeg,png,webp}',
);
const videos = import.meta.glob<{ default: string }>(
  '/src/assets/images/galleries/**/*.mp4',
);

// Resolvers
const resolveImage = async (url: string) => images[`/src/assets${url}`]?.();
const resolveVideo = async (url: string) => videos[`/src/assets${url}`]?.();

// Resolve all gallery media
const resolvedGallery = await Promise.all(
  galleryData.map(async (item: any) => ({
    ...item,
    resolvedImage: item.imageUrl ? await resolveImage(item.imageUrl) : null,
    resolvedVideo: item.videoUrl ? await resolveVideo(item.videoUrl) : null,
  })),
);
---

<section class="gallery">
  <Wrapper>
    <div class="content masonry gallery">
      {
        resolvedGallery.map((item) =>
          item.resolvedVideo && item.resolvedImage ? (
            <div class="item video-item reveal-on-scroll">
              <VideoWrapper
                videoSrc={item.resolvedVideo.default}
                alt={`Yanis Deplazes - ${item.alt}`}
                posterSrc={item.resolvedImage.default.src}
              />
            </div>
          ) : item.resolvedImage ? (
            <div class="item image-item reveal-on-scroll">
              <ImageWrapper
                src={item.resolvedImage.default}
                alt={`Yanis Deplazes - ${item.alt}`}
                caption={item.alt}
              />
            </div>
          ) : (
            <p>Media not found</p> // In case there's neither a video nor an image
          ),
        )
      }
    </div>
  </Wrapper>
</section>

<style lang="scss">
  .gallery {
    .masonry {
      position: relative;
      @media (min-width: 1000px) {
        opacity: 0;
        visibility: hidden;
      }

      @media (max-width: 999px) {
        height: unset !important;
        display: flex;
        flex-direction: column;
        gap: var(--space-l);
      }

      .item {
        height: auto;
        width: 100%;
      }
    }
  }
</style>

<script>
  function getColumnCount(): number {
    const width = window.innerWidth;
    if (width < 1000) return 1;
    return 2;
  }

  function resolveClamp(varName: string): number {
    const temp = document.createElement('div');
    temp.style.position = 'absolute';
    temp.style.visibility = 'hidden';
    temp.style.height = `var(${varName})`;
    document.body.appendChild(temp);

    const px = parseFloat(getComputedStyle(temp).height);
    document.body.removeChild(temp);

    return px;
  }

  function getItemHeight(item: HTMLElement, width: string): number {
    item.style.width = `${width}`;
    let height = item.clientHeight;
    return height;
  }

  function getTop(
    isVideo: boolean,
    index: number,
    imageIndex: number,
    rowGap: number,
    columns: Array<2>,
  ): number {
    let top;

    if (isVideo) {
      top = Math.max(columns[0], columns[1]) + (index === 0 ? 0 : rowGap);
    } else {
      top =
        Math.min(columns[0], columns[1]) +
        (index === 0 || (index === 1 && imageIndex !== 0) ? 0 : rowGap);
    }
    return top;
  }

  function getWidth(
    isVideo: boolean,
    columnWidthPx: number,
    columnCount: number,
  ) {
    return isVideo ? '100%' : columnCount === 1 ? '100%' : `${columnWidthPx}px`;
  }

  function setItemStyles(
    item: HTMLElement,
    width: string,
    height: string,
    top: number,
    isRight: boolean,
  ): void {
    item.style.width = width;
    item.style.height = height;
    item.style.top = `${top}px`;
    if (isRight) {
      item.style.right = '0';
    }
  }
  function setContainerStyles(
    container: HTMLElement,
    position: string,
    height: string,
    opacity: number,
    visibility: string,
  ): void {
    container.style.position = position;
    container.style.height = height; // Set the height based on the tallest column
    container.style.opacity = `${opacity}`; // Ensure the container is visible
    container.style.visibility = visibility; // Make the container visible after positioning
  }

  function initMasonryGrid(
    containerSelector = '.masonry',
    itemSelector = '.item',
    gap = 50,
  ): void {
    const container = document.querySelector(
      containerSelector,
    ) as HTMLElement | null;
    if (!container) return;

    const items = Array.from(
      container.querySelectorAll(itemSelector),
    ) as HTMLElement[];
    if (items.length === 0) return;

    // A function to ensure images are loaded and then proceed with layout calculation
    const processItems = () => {
      let columnCount = getColumnCount();
      if (columnCount === 1) {
        items.forEach((item, index) => {
          item.style.position = 'unset';
          item.style.width = '100%';
          item.style.height = 'auto';
        });
        container.style.height = '100%';
        return;
      }

      let columns = new Array(columnCount).fill(0);
      let containerWidth = container.clientWidth;
      let columnGap = gap;
      let rowGap = gap;

      const columnWidthPx = (containerWidth - columnGap) / columnCount;
      let imageIndex = 0;

      items.forEach((item, index) => {
        item.style.position = 'absolute';
        item.style.width = '';
        item.style.height = '';
        item.style.top = '';
        item.style.left = '';

        const isVideo: boolean = item.classList.contains('video-item');
        const width = getWidth(isVideo, columnWidthPx, getColumnCount());
        const height = getItemHeight(item, width);
        const top = getTop(isVideo, index, imageIndex, rowGap, columns);
        const colIndex = columns[0] <= columns[1] ? 0 : 1;
        const updatedColumnHeight = top + height;

        if (isVideo) {
          columns[0] = columns[1] = updatedColumnHeight;
        } else {
          columns[colIndex] = updatedColumnHeight;
        }

        const isRight = isVideo ? false : !!colIndex;
        imageIndex = isVideo ? 0 : +1;
        setItemStyles(item, width, height + 'px', top, isRight);
      });

      setContainerStyles(
        container,
        'relative',
        `${Math.max(columns[0], columns[1])}px`,
        1,
        'visible',
      );
    };

    // Call the layout function on window load and resize
    window.addEventListener('load', processItems); // Ensure all images are loaded before processing
    window.addEventListener('resize', processItems); // Recalculate on window resize

    // Initial layout call to set the grid before images load
    processItems();
  }

  // Initialize the masonry grid once the DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    const gap = resolveClamp('--space-5xl');
    initMasonryGrid('.masonry.gallery', '.item', gap); // Initialize Masonry Grid
  });
</script>
